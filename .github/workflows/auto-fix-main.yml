# ============================================
# Auto-Fix Main - AI-Powered CI Issue Resolver
# ============================================
# This workflow automatically detects and fixes CI failures using AI (GitHub Models/Copilot)
#
# Features:
# - Diagnoses CI environment issues (bundle install, dependency conflicts)
# - Analyzes test failures with AI-powered suggestions
# - Automatically applies fixes and commits changes
# - Handles common issues: gem version conflicts, deployment mode errors
# - Iterates up to 3 times to resolve issues
#
# Triggers:
# - Automatically on PR with Gemfile/Gemfile.lock changes
# - Manual: Actions tab ‚Üí "Auto-Fix Main" ‚Üí Run workflow
# - Comment: `/autofix` on any PR
#
# Requirements:
# - GitHub Models access (preview program)
# - Write permissions for repo
# ============================================

name: Auto-Fix Main

on:
  pull_request:
    paths:
      - 'Gemfile'
      - 'Gemfile.lock'
    types: [opened, reopened, synchronize]
  workflow_dispatch:  # Allow manual trigger
  issue_comment:
    types: [created]

jobs:
  auto-fix-dependabot:
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch' || (github.event_name == 'issue_comment' && github.event.comment.body == '/autofix')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      # ============================================
      # Checkout
      # ============================================
      - name: Get PR branch
        id: get_branch
        if: github.event_name == 'issue_comment'
        uses: xt0rted/pull-request-comment-branch@v2

      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'issue_comment' && steps.get_branch.outputs.head_ref || github.head_ref || github.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      # ============================================
      # Ruby Setup - NO CACHE, we'll handle manually
      # ============================================
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.10'
          bundler-cache: false  # CRITICAL: Don't use cache, we need to handle Gemfile changes

      # ============================================
      # Configure Bundler FIRST (before modifications)
      # ============================================
      - name: Configure Bundler for development mode
        run: |
          echo "üîß Configuring Bundler for development mode..."
          bundle config set --local deployment false
          bundle config set --local frozen false
          bundle config set --local path vendor/bundle
          echo "üìã Bundle configuration:"
          bundle config list

      # ============================================
      # Relax Gemfile & Install Dependencies
      # ============================================
      - name: Relax Gemfile constraints
        run: |
          echo "üìù Original Gemfile:"
          cat Gemfile | grep -A2 -B2 "sqlite3" || true
          
          if [ -f .github/scripts/relax_gemfile.rb ]; then
            echo "üîß Running relax_gemfile.rb..."
            ruby .github/scripts/relax_gemfile.rb
          fi
          
          echo "üìù Updated Gemfile:"
          cat Gemfile | grep -A2 -B2 "sqlite3" || true

      - name: Fix Gemfile/Gemfile.lock version mismatch
        id: fix_version_mismatch
        run: |
          echo "üîç Checking for Gemfile/Gemfile.lock version mismatches..."
          
          # Extract versions from Gemfile and Gemfile.lock
          GEMFILE_SQLITE=$(grep "gem.*sqlite3" Gemfile | head -1)
          LOCK_SQLITE_VERSION=$(grep "^    sqlite3 (" Gemfile.lock | grep -oP '\(\K[0-9.]+' | head -1 || echo "")
          LOCK_SQLITE_CONSTRAINT=$(grep "^  sqlite3 " Gemfile.lock | head -1)
          
          echo "Gemfile constraint: $GEMFILE_SQLITE"
          echo "Gemfile.lock version: $LOCK_SQLITE_VERSION"
          echo "Gemfile.lock constraint: $LOCK_SQLITE_CONSTRAINT"
          
          # Check for version mismatch (2.x in lock, 1.x in Gemfile)
          if [[ "$LOCK_SQLITE_VERSION" == 2.* ]] && echo "$GEMFILE_SQLITE" | grep -q "< 2\|~> 1"; then
            echo "‚ùå MISMATCH DETECTED: Gemfile.lock has sqlite3 2.x but Gemfile requires 1.x"
            echo "üîß Fixing Gemfile.lock to use sqlite3 1.7.3..."
            
            # Update Gemfile.lock to use 1.x version
            sed -i 's/sqlite3 (2\.[0-9.]*-x86_64-linux[^)]*)/sqlite3 (1.7.3-x86_64-linux)/g' Gemfile.lock
            sed -i 's/^  sqlite3 (~> 2\.[0-9.]*)/  sqlite3 (~> 1.4, < 2.0)/g' Gemfile.lock
            
            echo "‚úÖ Updated Gemfile.lock to match Gemfile constraints"
            echo "mismatch_fixed=true" >> $GITHUB_OUTPUT
            
            echo "Updated Gemfile.lock:"
            grep -A2 -B2 "sqlite3" Gemfile.lock | head -20
          elif [[ "$LOCK_SQLITE_VERSION" == 1.* ]] && echo "$GEMFILE_SQLITE" | grep -q "~> 2"; then
            echo "‚ùå MISMATCH DETECTED: Gemfile.lock has sqlite3 1.x but Gemfile requires 2.x"
            echo "‚ö†Ô∏è Manual update needed - sqlite3 2.x has breaking changes"
            echo "mismatch_fixed=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No version mismatch detected"
            echo "mismatch_fixed=false" >> $GITHUB_OUTPUT
          fi

      - name: Fix Puma/Rack compatibility
        id: fix_puma_rack
        run: |
          echo "üîç Checking for Puma/Rack compatibility issues..."
          
          # Check if Rack 3+ is in Gemfile.lock
          RACK_VERSION=$(grep "^    rack (" Gemfile.lock | grep -oP '\(\K[0-9.]+' | head -1 || echo "")
          # Check if Puma 5.x is in Gemfile.lock
          PUMA_VERSION=$(grep "^    puma (" Gemfile.lock | grep -oP '\(\K[0-9.]+' | head -1 || echo "")
          
          echo "Rack version in lock: $RACK_VERSION"
          echo "Puma version in lock: $PUMA_VERSION"
          
          # Detect incompatibility: Rack 3+ with Puma < 6
          if [[ "$RACK_VERSION" == 3.* ]] || [[ "$RACK_VERSION" == 4.* ]]; then
            if [[ "$PUMA_VERSION" == 5.* ]] || [[ -z "$PUMA_VERSION" && "$(grep 'gem.*puma' Gemfile)" == *'~> 5'* ]]; then
              echo "‚ùå CRITICAL: Rack 3+ is not compatible with Puma 5.x!"
              echo "üîß Fixing: Updating Puma constraint in Gemfile..."
              
              # Update Gemfile to allow Puma 6+
              sed -i 's/gem "puma", "~> 5\.0"/gem "puma", ">= 5.0"/g' Gemfile
              sed -i "s/gem 'puma', '~> 5\.0'/gem 'puma', '>= 5.0'/g" Gemfile
              
              echo "‚úÖ Updated Gemfile to allow Puma 6+"
              echo "puma_fixed=true" >> $GITHUB_OUTPUT
              
              # Show the change
              grep "puma" Gemfile || echo "Puma gem line not found"
              
              echo "üìù Changes:"
              git diff Gemfile || echo "No git available"
            else
              echo "‚úÖ No Puma/Rack incompatibility detected"
              echo "puma_fixed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚úÖ Rack 2.x or not yet resolved - no Puma restriction needed"
            echo "puma_fixed=false" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies
        id: bundle_install
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
        run: |
          echo "üì¶ Installing gems..."
          set +e
          
          # If Puma was fixed, use bundle update to resolve dependencies
          if [ "${{ steps.fix_puma_rack.outputs.puma_fixed }}" == "true" ]; then
            echo "üîÑ Running bundle update puma (since Puma constraint was relaxed)..."
            bundle update puma --jobs 4 > bundle_install.log 2>&1
          else
            echo "üì¶ Running bundle install..."
            bundle install --jobs 4 --retry 3 > bundle_install.log 2>&1
          fi
          
          BUNDLE_EXIT=$?
          
          cat bundle_install.log
          
          if [ $BUNDLE_EXIT -ne 0 ]; then
            echo "‚ùå Bundle install failed with exit code $BUNDLE_EXIT"
            echo "bundle_failed=true" >> $GITHUB_OUTPUT
            echo "exit_code=$BUNDLE_EXIT" >> $GITHUB_OUTPUT
            
            echo "## ‚ùå Bundle Install Failed" >> $GITHUB_STEP_SUMMARY
            echo '```text' >> $GITHUB_STEP_SUMMARY
            tail -n 50 bundle_install.log >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            
            exit 0  # Don't fail the step, we'll handle it
          else
            echo "‚úÖ Bundle install complete"
            bundle list | grep sqlite3
            echo "bundle_failed=false" >> $GITHUB_OUTPUT
          fi

      - name: AI fix for bundle install failure
        if: steps.bundle_install.outputs.bundle_failed == 'true'
        id: fix_bundle_failure
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ü§ñ Analyzing bundle install failure with AI..."
          
          cat > bundle_fix_prompt.txt << 'PROMPT_EOF'
          You are a Ruby bundler expert. A bundle install failed in CI. Help fix it.

          ## Error Log:
          PROMPT_EOF
          
          tail -n 100 bundle_install.log >> bundle_fix_prompt.txt
          
          cat >> bundle_fix_prompt.txt << 'PROMPT_EOF'

          ## Files Context:
          ### Gemfile:
          PROMPT_EOF
          
          cat Gemfile >> bundle_fix_prompt.txt
          
          cat >> bundle_fix_prompt.txt << 'PROMPT_EOF'

          ### Gemfile.lock (relevant sections):
          PROMPT_EOF
          
          grep -A20 "^PLATFORMS\|^GEM\|sqlite3" Gemfile.lock | head -50 >> bundle_fix_prompt.txt
          
          cat >> bundle_fix_prompt.txt << 'PROMPT_EOF'

          ## Question:
          What's causing the bundle install failure and how do I fix it?

          Provide:
          1. Root cause (1 sentence)
          2. Exact commands to fix it (bash script format)
          3. File changes needed (if any)

          Format your response as executable bash commands when possible.
          PROMPT_EOF
          
          if cat bundle_fix_prompt.txt | gh models run gpt-4o-mini - > bundle_ai_fix.txt 2>&1; then
            echo "‚úÖ Got AI fix suggestions"
            echo "ai_fix_available=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå AI unavailable, using fallback fix"
            echo "ai_fix_available=false" >> $GITHUB_OUTPUT
            
            # Fallback: Common fix for deployment mode issues
            cat > bundle_ai_fix.txt << 'FALLBACK'
          Root cause: Bundle is in deployment mode but Gemfile was modified.

          Fix commands:
          bundle config unset deployment
          bundle config unset frozen  
          bundle config set --local deployment false
          bundle config set --local frozen false
          bundle install --jobs 4
          FALLBACK
            echo "ai_fix_available=true" >> $GITHUB_OUTPUT
          fi
          
          echo "## ü§ñ AI Fix for Bundle Failure" >> $GITHUB_STEP_SUMMARY
          echo '```text' >> $GITHUB_STEP_SUMMARY
          cat bundle_ai_fix.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          cat bundle_ai_fix.txt

      - name: Apply bundle fix and retry
        if: steps.fix_bundle_failure.outputs.ai_fix_available == 'true'
        id: retry_bundle
        continue-on-error: true
        run: |
          echo "üîß Applying bundle fix..."
          
          # Extract and run bash commands from AI response
          if grep -q "bundle config" bundle_ai_fix.txt; then
            echo "Running AI-suggested commands..."
            grep "bundle config\|bundle install" bundle_ai_fix.txt | while read cmd; do
              echo "Running: $cmd"
              eval "$cmd" || true
            done
          fi
          
          # Ensure deployment mode is off
          bundle config unset deployment 2>/dev/null || true
          bundle config unset frozen 2>/dev/null || true
          bundle config set --local deployment false
          bundle config set --local frozen false
          
          # Retry bundle install
          echo "üì¶ Retrying bundle install..."
          if bundle install --jobs 4 --retry 3; then
            echo "‚úÖ Bundle install succeeded!"
            echo "bundle_fixed=true" >> $GITHUB_OUTPUT
            bundle list | grep sqlite3
          else
            echo "‚ùå Bundle install still failing"
            echo "bundle_fixed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Commit bundle fixes
        if: |
          steps.retry_bundle.outputs.bundle_fixed == 'true' || 
          steps.fix_puma_rack.outputs.puma_fixed == 'true'
        continue-on-error: true
        run: |
          if git status --porcelain | grep -q .; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            git add Gemfile Gemfile.lock .bundle/config 2>/dev/null || true
            
            # Build commit message based on what was fixed
            COMMIT_MSG="fix(deps): resolve gem compatibility issues"
            COMMIT_BODY="Fixes:"
            
            if [ "${{ steps.fix_puma_rack.outputs.puma_fixed }}" == "true" ]; then
              COMMIT_BODY="${COMMIT_BODY}
          - Fixed Puma/Rack incompatibility (Rack 3+ requires Puma 6+)"
            fi
            
            if [ "${{ steps.retry_bundle.outputs.bundle_fixed }}" == "true" ]; then
              COMMIT_BODY="${COMMIT_BODY}
          - Fixed deployment mode configuration
          - Updated gem constraints for compatibility"
            fi
            
            COMMIT_BODY="${COMMIT_BODY}

          Co-authored-by: GitHub Actions <github-actions[bot]@users.noreply.github.com>"
            
            git commit -m "$COMMIT_MSG" -m "$COMMIT_BODY" || true
            
            git push origin HEAD || echo "Could not push changes"
          fi

      - name: Install GitHub Models extension
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh extension install github/gh-models 2>/dev/null || echo "‚ÑπÔ∏è gh-models extension already installed or unavailable"
          gh extension list | grep -i models || echo "‚ö†Ô∏è Models extension not available"

      - name: Generate gem change summary
        id: gem_summary
        continue-on-error: true
        run: |
          if [ -f .github/scripts/gem_diff.rb ]; then
            echo "üìä Generating gem diff..."
            ruby .github/scripts/gem_diff.rb > gem_summary.txt 2>&1 || true
            if [ -f gem_summary.txt ]; then
              echo "GEM_SUMMARY<<EOF" >> $GITHUB_ENV
              cat gem_summary.txt >> $GITHUB_ENV
              echo "EOF" >> $GITHUB_ENV
            fi
          fi

      # ============================================
      # CI Diagnostic - Check for common issues
      # ============================================
      - name: Diagnose CI environment and issues
        id: ci_diagnostic
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Running CI Diagnostics..." >> ci_diagnostic.txt
          echo "================================" >> ci_diagnostic.txt
          echo "" >> ci_diagnostic.txt
          
          # Check Ruby/Bundler versions
          echo "## Environment Info:" >> ci_diagnostic.txt
          echo "Ruby version: $(ruby --version)" >> ci_diagnostic.txt
          echo "Bundler version: $(bundle --version)" >> ci_diagnostic.txt
          echo "Rails version: $(bundle exec rails --version 2>&1 || echo 'Not installed')" >> ci_diagnostic.txt
          echo "" >> ci_diagnostic.txt
          
          # Check Gemfile constraints
          echo "## Gemfile Analysis:" >> ci_diagnostic.txt
          if grep -n "sqlite3" Gemfile; then
            echo "‚úì sqlite3 found in Gemfile" >> ci_diagnostic.txt
            grep "sqlite3" Gemfile >> ci_diagnostic.txt
          else
            echo "‚ö†Ô∏è sqlite3 not found in Gemfile" >> ci_diagnostic.txt
          fi
          echo "" >> ci_diagnostic.txt
          
          # Check Gemfile.lock for version conflicts
          echo "## Gemfile.lock Analysis:" >> ci_diagnostic.txt
          if grep -A5 "^  sqlite3" Gemfile.lock; then
            echo "Installed sqlite3 version:" >> ci_diagnostic.txt
            grep "sqlite3 (" Gemfile.lock >> ci_diagnostic.txt
          fi
          echo "" >> ci_diagnostic.txt
          
          # Check for version mismatches
          echo "## Potential Issues:" >> ci_diagnostic.txt
          GEMFILE_CONSTRAINT=$(grep "gem.*sqlite3" Gemfile | head -1)
          LOCK_VERSION=$(grep "sqlite3 (" Gemfile.lock | grep -oP '\(\K[0-9.]+' | head -1 || echo "unknown")
          LOCK_CONSTRAINT=$(grep "^  sqlite3 " Gemfile.lock | head -1 || echo "unknown")
          
          echo "Gemfile constraint: $GEMFILE_CONSTRAINT" >> ci_diagnostic.txt
          echo "Gemfile.lock has version: $LOCK_VERSION" >> ci_diagnostic.txt
          echo "Gemfile.lock constraint: $LOCK_CONSTRAINT" >> ci_diagnostic.txt
          echo "" >> ci_diagnostic.txt
          
          # Check for 2.x in lock with 1.x in Gemfile
          if [[ "$LOCK_VERSION" == 2.* ]] && echo "$GEMFILE_CONSTRAINT" | grep -q "< 2\|~> 1"; then
            echo "‚ùå CRITICAL: Gemfile/Gemfile.lock mismatch!" >> ci_diagnostic.txt
            echo "   - Gemfile requires: sqlite3 1.x (or < 2.0)" >> ci_diagnostic.txt
            echo "   - Gemfile.lock has: sqlite3 $LOCK_VERSION" >> ci_diagnostic.txt
            echo "   - This causes bundle install to fail in deployment mode" >> ci_diagnostic.txt
            echo "   - Auto-fix will update Gemfile.lock to match" >> ci_diagnostic.txt
            echo "requires_fix=true" >> $GITHUB_OUTPUT
          # Check for 1.x in lock with 2.x in Gemfile
          elif [[ "$LOCK_VERSION" == 1.* ]] && echo "$GEMFILE_CONSTRAINT" | grep -q "~> 2"; then
            echo "‚ö†Ô∏è WARNING: Gemfile wants 2.x but lock has 1.x" >> ci_diagnostic.txt
            echo "   - sqlite3 2.x has breaking changes" >> ci_diagnostic.txt
            echo "   - Manual review recommended" >> ci_diagnostic.txt
            echo "requires_fix=true" >> $GITHUB_OUTPUT
          # Check if version fixed flag was set
          elif [ "${{ steps.fix_version_mismatch.outputs.mismatch_fixed }}" == "true" ]; then
            echo "‚úÖ Version mismatch was auto-fixed" >> ci_diagnostic.txt
            echo "requires_fix=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No version mismatch detected" >> ci_diagnostic.txt
            echo "requires_fix=false" >> $GITHUB_OUTPUT
          fi
          
          # Check bundle config
          echo "" >> ci_diagnostic.txt
          echo "## Bundle Configuration:" >> ci_diagnostic.txt
          bundle config list >> ci_diagnostic.txt
          
          cat ci_diagnostic.txt
          
          echo "## CI Diagnostic Report" >> $GITHUB_STEP_SUMMARY
          echo '```text' >> $GITHUB_STEP_SUMMARY
          cat ci_diagnostic.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: AI-powered CI issue analysis
        if: steps.ci_diagnostic.outputs.requires_fix == 'true'
        id: ai_ci_fix
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ü§ñ Asking AI to analyze CI issues..."
          
          # Create AI prompt with context
          cat > ci_fix_prompt.txt << 'PROMPT_EOF'
          You are a GitHub Actions CI/CD expert and Ruby on Rails developer. Analyze this CI failure and provide fixes.

          ## Context:
          - This is a GitHub Actions workflow for a Rails application
          - Dependabot may have upgraded gems causing compatibility issues
          - Common issue: sqlite3 gem upgraded from 1.x to 2.x (breaking change)

          ## Diagnostic Information:
          PROMPT_EOF
          
          cat ci_diagnostic.txt >> ci_fix_prompt.txt
          
          cat >> ci_fix_prompt.txt << 'PROMPT_EOF'

          ## Your Task:
          Provide SPECIFIC fixes in this exact format:

          ### Analysis:
          [Explain what's wrong in 2-3 sentences]

          ### Fix 1: Gemfile
          ```ruby
          # Updated Gemfile content (FULL FILE or just the lines to change)
          gem "sqlite3", "~> 1.4", "< 2.0"
          ```

          ### Fix 2: Gemfile.lock (if needed)
          ```text
          # Specify EXACT line numbers and changes needed
          Line 205: Change "sqlite3 (2.9.0-x86_64-linux-gnu)" to "sqlite3 (1.7.3-x86_64-linux)"
          Line 251: Change "sqlite3 (~> 2.9)" to "sqlite3 (~> 1.4, < 2.0)"
          ```

          ### Fix 3: Workflow changes (if needed)
          ```yaml
          # Any workflow file changes needed
          ```

          ### Commands to run:
          ```bash
          # Shell commands to fix the issue
          bundle config set --local deployment false
          bundle update sqlite3
          ```

          Be specific and actionable. Only suggest changes that are necessary.
          PROMPT_EOF
          
          echo "üì§ Sending prompt to AI..."
          cat ci_fix_prompt.txt
          
          # Try to get AI response
          if cat ci_fix_prompt.txt | gh models run gpt-4o-mini - > ai_ci_fix.txt 2>&1; then
            echo "‚úÖ Got AI analysis"
            echo "ai_fix_available=true" >> $GITHUB_OUTPUT
          elif cat ci_fix_prompt.txt | gh models run openai-gpt-4o-mini - > ai_ci_fix.txt 2>&1; then
            echo "‚úÖ Got AI analysis (backup model)"
            echo "ai_fix_available=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå AI models unavailable" > ai_ci_fix.txt
            echo "ai_fix_available=false" >> $GITHUB_OUTPUT
          fi
          
          echo "## ü§ñ AI Analysis of CI Issues" >> $GITHUB_STEP_SUMMARY
          echo '```text' >> $GITHUB_STEP_SUMMARY
          cat ai_ci_fix.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          cat ai_ci_fix.txt

      - name: Apply AI-suggested CI fixes
        if: steps.ai_ci_fix.outputs.ai_fix_available == 'true'
        id: apply_ci_fixes
        continue-on-error: true
        run: |
          echo "üîß Applying AI-suggested fixes..."
          
          # Check if AI suggested updating Gemfile.lock
          if grep -q "Gemfile.lock" ai_ci_fix.txt; then
            echo "üìù AI suggested Gemfile.lock changes"
            
            # Look for specific version recommendations
            if grep -q "sqlite3.*1\.[0-9]" ai_ci_fix.txt; then
              echo "Downgrading sqlite3 in Gemfile.lock..."
              
              # Update Gemfile.lock to use 1.x
              sed -i 's/sqlite3 (2\.9\.0-x86_64-linux-gnu)/sqlite3 (1.7.3-x86_64-linux)/g' Gemfile.lock
              sed -i 's/sqlite3 (~> 2\.9)/sqlite3 (~> 1.4, < 2.0)/g' Gemfile.lock
              
              echo "‚úÖ Updated Gemfile.lock"
            fi
          fi
          
          # Re-run bundle install with updated lock file
          if git diff --name-only | grep -q 'Gemfile'; then
            echo "üì¶ Running bundle install after Gemfile changes..."
            bundle config set --local deployment false
            bundle config set --local frozen false
            bundle install --jobs 4 || echo "‚ö†Ô∏è Bundle install had issues"
          fi
          
          # Check if changes were made
          if git status --porcelain | grep -q .; then
            echo "‚úÖ CI fixes applied"
            echo "fixes_applied=true" >> $GITHUB_OUTPUT
            
            git diff
          else
            echo "‚ÑπÔ∏è No changes needed"
            echo "fixes_applied=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit CI fixes
        if: steps.apply_ci_fixes.outputs.fixes_applied == 'true'
        continue-on-error: true
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add -A
          git commit -m "fix(ci): apply AI-suggested fixes for CI compatibility issues

          - Fixed sqlite3 version compatibility
          - Updated Gemfile/Gemfile.lock constraints
          - Resolved bundle install conflicts
          
          Co-authored-by: GitHub Actions <github-actions[bot]@users.noreply.github.com>" || echo "Nothing to commit"
          
          git push origin HEAD || echo "‚ö†Ô∏è Push failed, may need manual intervention"

      # ============================================
      # Initial test run
      # ============================================
      - name: Run initial tests
        id: initial_tests
        continue-on-error: true
        run: |
          echo "üß™ Running initial tests..."
          set +e
          bin/rails test:prepare > test_output.txt 2>&1
          bin/rails test >> test_output.txt 2>&1
          TEST_EXIT=$?
          echo "test_exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT
          
          echo "## Initial Test Output" >> $GITHUB_STEP_SUMMARY
          echo '```text' >> $GITHUB_STEP_SUMMARY
          tail -n 100 test_output.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "Exit code: $TEST_EXIT" >> $GITHUB_STEP_SUMMARY
          
          if [ "$TEST_EXIT" == "0" ]; then
            echo "‚úÖ Tests passed!"
          else
            echo "‚ùå Tests failed with exit code $TEST_EXIT"
          fi

      # ============================================
      # Auto-fix loop - Iteration 1
      # ============================================
      - name: Auto-fix iteration 1
        if: steps.initial_tests.outputs.test_exit_code != '0'
        id: fix_iteration_1
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Iteration 1: Analyzing failures and generating fixes..."
          
          # Create comprehensive context for AI
          cat > ai_context.txt << 'CONTEXT_EOF'
          # Context Information

          ## Repository Structure:
          CONTEXT_EOF
          
          find . -name "*.rb" -o -name "*.yml" -o -name "Gemfile*" | grep -v vendor | grep -v ".git" | head -30 >> ai_context.txt
          
          cat >> ai_context.txt << 'CONTEXT_EOF'

          ## Gemfile:
          CONTEXT_EOF
          cat Gemfile >> ai_context.txt
          
          cat >> ai_context.txt << 'CONTEXT_EOF'

          ## Recent Changes:
          CONTEXT_EOF
          git log --oneline -5 >> ai_context.txt 2>/dev/null || echo "No git history" >> ai_context.txt
          
          cat >> ai_context.txt << 'CONTEXT_EOF'

          ## Bundle Info:
          CONTEXT_EOF
          bundle list 2>&1 | grep -i "sqlite3\|rails\|ruby" >> ai_context.txt
          
          if [ ! -f .github/scripts/build_ai_prompt.sh ]; then
            echo "‚ö†Ô∏è build_ai_prompt.sh not found, creating AI prompt manually..."
            
            cat > prompt_1.txt << 'PROMPT_EOF'
          You are an expert Ruby on Rails and CI/CD engineer. Tests failed in CI. Analyze and fix.

          ## Test Output (last 100 lines):
          PROMPT_EOF
            
            tail -n 100 test_output.txt >> prompt_1.txt
            
            cat >> prompt_1.txt << 'PROMPT_EOF'

          ## Context:
          PROMPT_EOF
            cat ai_context.txt >> prompt_1.txt
            
            cat >> prompt_1.txt << 'PROMPT_EOF'

          ## Your Task:
          1. Identify the root cause of test failures
          2. Provide specific fixes (file paths, line numbers, exact code)
          3. Format response as:

          ### ANALYSIS:
          [Brief explanation]

          ### FIX: path/to/file.rb
          ```ruby
          # Exact code to add/change
          ```

          ### COMMIT_MESSAGE: 
          fix: [brief description]

          Be specific and actionable.
          PROMPT_EOF
          else
            chmod +x .github/scripts/build_ai_prompt.sh
            .github/scripts/build_ai_prompt.sh 1 test_output.txt > prompt_1.txt 2>&1 || true
            # Append our context
            echo -e "\n## Additional Context:" >> prompt_1.txt
            cat ai_context.txt >> prompt_1.txt
          fi
          
          echo "## AI Prompt (iteration 1)" >> $GITHUB_STEP_SUMMARY
          echo '```text' >> $GITHUB_STEP_SUMMARY
          head -50 prompt_1.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          # Try multiple AI models with better error handling
          echo "ü§ñ Requesting AI analysis..."
          if cat prompt_1.txt | gh models run gpt-4o-mini - > fixes_iteration_1.txt 2>&1; then
            echo "‚úÖ Got AI response from gpt-4o-mini"
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          elif cat prompt_1.txt | gh models run openai-gpt-4o-mini - > fixes_iteration_1.txt 2>&1; then
            echo "‚úÖ Got AI response from openai-gpt-4o-mini"
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          elif cat prompt_1.txt | gh models run gpt-3.5-turbo - > fixes_iteration_1.txt 2>&1; then
            echo "‚úÖ Got AI response from gpt-3.5-turbo"
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to get AI suggestions - all models unavailable" 
            echo "Error: Check if GitHub Models is enabled for your account" > fixes_iteration_1.txt
            echo "Visit: https://github.com/marketplace/models" >> fixes_iteration_1.txt
            echo "fixes_generated=false" >> $GITHUB_OUTPUT
          fi
          
          echo "## AI Response (iteration 1)" >> $GITHUB_STEP_SUMMARY
          echo '```text' >> $GITHUB_STEP_SUMMARY
          cat fixes_iteration_1.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Apply fixes iteration 1
        if: steps.fix_iteration_1.outputs.fixes_generated == 'true'
        id: apply_fixes_1
        continue-on-error: true
        run: |
          echo "üîß Applying fixes from iteration 1..."
          
          if [ ! -f .github/scripts/apply_fixes.py ]; then
            echo "‚ö†Ô∏è apply_fixes.py not found"
            echo "fixes_applied=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          python3 .github/scripts/apply_fixes.py fixes_iteration_1.txt || true

          # Re-run bundle install if Gemfile was modified
          if git diff --name-only | grep -q 'Gemfile'; then
            echo "üì¶ Gemfile was modified, re-running bundle install..."
            bundle install --jobs 4
          fi

          if git status --porcelain | grep -q .; then
            echo "‚úÖ Fixes applied"
            echo "fixes_applied=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No changes to apply"
            echo "fixes_applied=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push iteration 1
        if: steps.apply_fixes_1.outputs.fixes_applied == 'true'
        continue-on-error: true
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          COMMIT_MSG=$(grep "COMMIT_MESSAGE:" fixes_iteration_1.txt 2>/dev/null | head -1 | sed 's/COMMIT_MESSAGE: *//' | tr -d '\r')
          if [ -z "$COMMIT_MSG" ]; then 
            COMMIT_MSG="fix: auto-fix iteration 1"
          fi
          
          git add -A
          git commit -m "$COMMIT_MSG" || echo "Nothing to commit"
          git push origin HEAD || echo "Push failed"

      - name: Test after iteration 1
        if: steps.apply_fixes_1.outputs.fixes_applied == 'true'
        id: test_after_fix_1
        continue-on-error: true
        run: |
          echo "üß™ Testing after iteration 1..."
          set +e
          bin/rails test:prepare > test_output_1.txt 2>&1
          bin/rails test >> test_output_1.txt 2>&1
          TEST_EXIT=$?
          tail -n 50 test_output_1.txt
          echo "test_exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT

      # ============================================
      # Auto-fix loop - Iteration 2
      # ============================================
      - name: Auto-fix iteration 2
        if: steps.test_after_fix_1.outputs.test_exit_code != '0' && steps.test_after_fix_1.outputs.test_exit_code != ''
        id: fix_iteration_2
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Iteration 2: Analyzing remaining failures..."
          
          if [ ! -f .github/scripts/build_ai_prompt.sh ]; then
            echo "fixes_generated=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          chmod +x .github/scripts/build_ai_prompt.sh
          .github/scripts/build_ai_prompt.sh 2 test_output_1.txt > prompt_2.txt 2>&1 || true
          
          if cat prompt_2.txt | gh models run gpt-4o-mini - > fixes_iteration_2.txt 2>&1; then
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          elif cat prompt_2.txt | gh models run openai-gpt-4o-mini - > fixes_iteration_2.txt 2>&1; then
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          else
            echo "Failed - models unavailable" > fixes_iteration_2.txt
            echo "fixes_generated=false" >> $GITHUB_OUTPUT
          fi
          cat fixes_iteration_2.txt

      - name: Apply fixes iteration 2
        if: steps.fix_iteration_2.outputs.fixes_generated == 'true'
        continue-on-error: true
        run: |
          python3 .github/scripts/apply_fixes.py fixes_iteration_2.txt || true

          if git diff --name-only | grep -q 'Gemfile'; then
            bundle install --jobs 4
          fi

          if git status --porcelain | grep -q .; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            COMMIT_MSG=$(grep "COMMIT_MESSAGE:" fixes_iteration_2.txt 2>/dev/null | head -1 | sed 's/COMMIT_MESSAGE: *//' | tr -d '\r')
            if [ -z "$COMMIT_MSG" ]; then COMMIT_MSG="fix: iteration 2"; fi
            git add -A
            git commit -m "$COMMIT_MSG" || true
            git push origin HEAD || true
          fi

      - name: Test after iteration 2
        if: steps.fix_iteration_2.outputs.fixes_generated == 'true'
        id: test_after_fix_2
        continue-on-error: true
        run: |
          set +e
          bin/rails test:prepare > test_output_2.txt 2>&1
          bin/rails test >> test_output_2.txt 2>&1
          TEST_EXIT=$?
          tail -n 50 test_output_2.txt
          echo "test_exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT

      # ============================================
      # Auto-fix loop - Iteration 3 (Final)
      # ============================================
      - name: Auto-fix iteration 3 (final)
        if: steps.test_after_fix_2.outputs.test_exit_code != '0' && steps.test_after_fix_2.outputs.test_exit_code != ''
        id: fix_iteration_3
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîç Iteration 3: Final fix attempt..."
          
          if [ ! -f .github/scripts/build_ai_prompt.sh ]; then
            echo "fixes_generated=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          chmod +x .github/scripts/build_ai_prompt.sh
          .github/scripts/build_ai_prompt.sh 3 test_output_2.txt > prompt_3.txt 2>&1 || true
          
          if cat prompt_3.txt | gh models run gpt-4o-mini - > fixes_iteration_3.txt 2>&1; then
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          elif cat prompt_3.txt | gh models run openai-gpt-4o-mini - > fixes_iteration_3.txt 2>&1; then
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          else
            echo "Failed - models unavailable" > fixes_iteration_3.txt
            echo "fixes_generated=false" >> $GITHUB_OUTPUT
          fi
          cat fixes_iteration_3.txt

      - name: Apply fixes iteration 3
        if: steps.fix_iteration_3.outputs.fixes_generated == 'true'
        continue-on-error: true
        run: |
          python3 .github/scripts/apply_fixes.py fixes_iteration_3.txt || true

          if git diff --name-only | grep -q 'Gemfile'; then
            bundle install --jobs 4
          fi

          if git status --porcelain | grep -q .; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            COMMIT_MSG=$(grep "COMMIT_MESSAGE:" fixes_iteration_3.txt 2>/dev/null | head -1 | sed 's/COMMIT_MESSAGE: *//' | tr -d '\r')
            if [ -z "$COMMIT_MSG" ]; then COMMIT_MSG="fix: iteration 3 final"; fi
            git add -A
            git commit -m "$COMMIT_MSG" || true
            git push origin HEAD || true
          fi

      - name: Final test
        if: steps.fix_iteration_3.outputs.fixes_generated == 'true'
        id: final_test
        continue-on-error: true
        run: |
          set +e
          bin/rails test:prepare > final_test_output.txt 2>&1
          bin/rails test >> final_test_output.txt 2>&1
          TEST_EXIT=$?
          tail -n 50 final_test_output.txt
          echo "test_exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT

      # ============================================
      # Summary
      # ============================================
      - name: Generate detailed fix report
        if: always()
        continue-on-error: true
        run: |
          cat > fix_report.md << 'REPORT_EOF'
          # ü§ñ AI-Powered CI Fix Report

          ## üîç Diagnostics Performed

          ### Environment Check
          REPORT_EOF
          
          if [ -f ci_diagnostic.txt ]; then
            cat ci_diagnostic.txt >> fix_report.md
          else
            echo "No diagnostic data available" >> fix_report.md
          fi
          
          cat >> fix_report.md << 'REPORT_EOF'

          ## ü§ñ AI Analysis Results

          ### CI Issues
          REPORT_EOF
          
          if [ -f ai_ci_fix.txt ]; then
            echo "‚úÖ AI analyzed CI configuration issues" >> fix_report.md
            echo '```' >> fix_report.md
            head -50 ai_ci_fix.txt >> fix_report.md
            echo '```' >> fix_report.md
          else
            echo "No CI-specific analysis performed" >> fix_report.md
          fi
          
          cat >> fix_report.md << 'REPORT_EOF'

          ### Bundle Install Issues
          REPORT_EOF
          
          if [ -f bundle_ai_fix.txt ]; then
            echo "‚úÖ AI analyzed bundle install failures" >> fix_report.md
            echo '```' >> fix_report.md
            cat bundle_ai_fix.txt >> fix_report.md
            echo '```' >> fix_report.md
          else
            echo "No bundle issues detected" >> fix_report.md
          fi
          
          cat >> fix_report.md << 'REPORT_EOF'

          ### Test Failures
          REPORT_EOF
          
          if [ -f fixes_iteration_1.txt ]; then
            echo "‚úÖ AI analyzed test failures (Iteration 1)" >> fix_report.md
          fi
          if [ -f fixes_iteration_2.txt ]; then
            echo "‚úÖ AI provided additional fixes (Iteration 2)" >> fix_report.md
          fi
          if [ -f fixes_iteration_3.txt ]; then
            echo "‚úÖ AI attempted final fixes (Iteration 3)" >> fix_report.md
          fi
          
          cat >> fix_report.md << 'REPORT_EOF'

          ## üìä Results Summary

          REPORT_EOF
          
          echo "- CI Diagnostic: ${{ steps.ci_diagnostic.outcome }}" >> fix_report.md
          echo "- AI CI Fix: ${{ steps.ai_ci_fix.outcome }}" >> fix_report.md
          echo "- Bundle Install: ${{ steps.bundle_install.outcome }}" >> fix_report.md
          echo "- Bundle Fix Applied: ${{ steps.retry_bundle.outcome }}" >> fix_report.md
          echo "- Initial Tests: ${{ steps.initial_tests.outcome }}" >> fix_report.md
          echo "- Test After Fix 1: ${{ steps.test_after_fix_1.outcome }}" >> fix_report.md
          echo "- Test After Fix 2: ${{ steps.test_after_fix_2.outcome }}" >> fix_report.md
          echo "- Final Test: ${{ steps.final_test.outcome }}" >> fix_report.md
          
          cat >> fix_report.md << 'REPORT_EOF'

          ## üéØ Recommendations

          REPORT_EOF
          
          INITIAL_EXIT="${{ steps.initial_tests.outputs.test_exit_code }}"
          FINAL_EXIT="${{ steps.final_test.outputs.test_exit_code }}"
          BUNDLE_FAILED="${{ steps.bundle_install.outputs.bundle_failed }}"
          
          if [ "$BUNDLE_FAILED" == "true" ]; then
            echo "- ‚ö†Ô∏è **Bundle install is failing** - Review Gemfile.lock for version conflicts" >> fix_report.md
            echo "- Consider pinning breaking gems (e.g., sqlite3 < 2.0)" >> fix_report.md
          fi
          
          if [ "$INITIAL_EXIT" != "0" ] && [ "$FINAL_EXIT" == "0" ]; then
            echo "- ‚úÖ **AI successfully fixed the issues!**" >> fix_report.md
            echo "- Review the commits made by github-actions[bot]" >> fix_report.md
          elif [ "$INITIAL_EXIT" != "0" ]; then
            echo "- ‚ùå **Manual intervention needed**" >> fix_report.md
            echo "- Review AI suggestions in the logs above" >> fix_report.md
            echo "- Check if GitHub Models has API access" >> fix_report.md
            echo "- Consider running fixes locally: \`bundle update <gem>\`" >> fix_report.md
          fi
          
          cat fix_report.md
          
          # Also output to step summary
          cat fix_report.md >> $GITHUB_STEP_SUMMARY

      - name: Summary
        if: always()
        run: |
          echo "## üéØ Auto-Fix Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          INITIAL_EXIT="${{ steps.initial_tests.outputs.test_exit_code }}"
          FIX1_EXIT="${{ steps.test_after_fix_1.outputs.test_exit_code }}"
          FIX2_EXIT="${{ steps.test_after_fix_2.outputs.test_exit_code }}"
          FINAL_EXIT="${{ steps.final_test.outputs.test_exit_code }}"
          BUNDLE_FAILED="${{ steps.bundle_install.outputs.bundle_failed }}"
          BUNDLE_FIXED="${{ steps.retry_bundle.outputs.bundle_fixed }}"

          echo "### Test Results:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check bundle issues first
          if [ "$BUNDLE_FAILED" == "true" ]; then
            if [ "$BUNDLE_FIXED" == "true" ]; then
              echo "‚ö†Ô∏è Bundle install initially failed but **AI fixed it**" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ùå **Bundle install failed** - CI cannot proceed" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Action needed:** Review Gemfile/Gemfile.lock for version conflicts" >> $GITHUB_STEP_SUMMARY
              exit 0
            fi
          fi

          if [ "$INITIAL_EXIT" == "0" ]; then
            echo "‚úÖ **Tests passed on first run** - no fixes needed" >> $GITHUB_STEP_SUMMARY
          elif [ -n "$INITIAL_EXIT" ]; then
            echo "‚ùå Initial tests failed (exit code: $INITIAL_EXIT)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$FIX1_EXIT" == "0" ]; then
              echo "‚úÖ **Tests passed after AI fix iteration 1**" >> $GITHUB_STEP_SUMMARY
            elif [ "$FIX2_EXIT" == "0" ]; then
              echo "‚úÖ **Tests passed after AI fix iteration 2**" >> $GITHUB_STEP_SUMMARY
            elif [ "$FINAL_EXIT" == "0" ]; then
              echo "‚úÖ **Tests passed after AI fix iteration 3**" >> $GITHUB_STEP_SUMMARY
            elif [ -n "$FINAL_EXIT" ]; then
              echo "‚ùå **Tests still failing after 3 AI fix iterations**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "üîç **Manual review required**" >> $GITHUB_STEP_SUMMARY
              echo "- Check AI suggestions in workflow logs" >> $GITHUB_STEP_SUMMARY
              echo "- Review commits made by github-actions[bot]" >> $GITHUB_STEP_SUMMARY
              echo "- Verify GitHub Models API access" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ö†Ô∏è **Auto-fix iterations incomplete**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Check workflow logs for details" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ö†Ô∏è **Initial tests did not run**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check workflow conditions and bundle install" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "ü§ñ **Powered by:** GitHub Models AI + Copilot" >> $GITHUB_STEP_SUMMARY
          echo "üìù **Workflow:** \`auto-fix-main\`" >> $GITHUB_STEP_SUMMARY
          echo "üîó **Need help?** Review the detailed fix report above" >> $GITHUB_STEP_SUMMARY
