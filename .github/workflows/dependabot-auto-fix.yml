name: Dependabot Auto-Fix

on:
  pull_request:
    paths:
      - 'Gemfile'
      - 'Gemfile.lock'
    types: [opened, reopened, synchronize]
  issue_comment:
    types: [created]

jobs:
  auto-fix-dependabot:
    # if: ${{ github.actor == 'dependabot[bot]' }}  # Uncomment after testing
    if: github.event_name == 'pull_request' || (github.event_name == 'issue_comment' && github.event.comment.body == '/autofix')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      # For an issue comment, the checkout ref is the PR ref
      - name: Get PR branch
        id: get_branch
        if: github.event_name == 'issue_comment'
        uses: xt0rted/pull-request-comment-branch@v2

      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'issue_comment' && steps.get_branch.outputs.head_ref || github.head_ref }}
          fetch-depth: 0

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 'default'
          bundler-cache: false  # Disable auto bundle install, we'll do it manually after relaxing Gemfile

      - name: Install dependencies
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Relax Gemfile constraints BEFORE bundle install
          if [ -f .github/scripts/relax_gemfile.rb ]; then
            ruby .github/scripts/relax_gemfile.rb
          fi
          
          # Configure bundle to NOT use deployment mode (allows Gemfile changes)
          bundle config set --local deployment false
          bundle config set --local path vendor/bundle
          bundle install --jobs 4

      # ============================================
      # Generate gem change summary
      # ============================================
      - name: Generate gem change summary
        id: gem_summary
        run: |
          if [ -f .github/scripts/gem_diff.rb ]; then
            ruby .github/scripts/gem_diff.rb > gem_summary.txt 2>&1
            echo "GEM_SUMMARY<<EOF" >> $GITHUB_ENV
            cat gem_summary.txt >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          fi

      # ============================================
      # Detect Dependency Upgrades
      # ============================================
      - name: Detect dependency version changes
        id: detect_upgrades
        continue-on-error: true
        run: |
          echo "ðŸ” Detecting dependency upgrades from Dependabot PR..."
          
          # Get base branch Gemfile.lock for comparison
          git fetch origin ${{ github.base_ref || 'main' }} --depth=1 2>/dev/null || true
          
          if git show origin/${{ github.base_ref || 'main' }}:Gemfile.lock > old_gemfile.lock 2>/dev/null; then
            echo "âœ… Got base branch Gemfile.lock for comparison"
            
            # Compare versions and find upgrades
            cat > detect_upgrades.rb << 'RUBY_EOF'
          require 'set'
          
          def parse_versions(lockfile)
            versions = {}
            File.readlines(lockfile).each do |line|
              if line =~ /^\s{4}(\S+)\s+\(([^)]+)\)/
                gem_name = $1
                version = $2.split(',').first.strip
                versions[gem_name] = version
              end
            end
            versions
          end
          
          old_versions = parse_versions('old_gemfile.lock')
          new_versions = parse_versions('Gemfile.lock')
          
          upgrades = []
          new_versions.each do |gem, new_ver|
            old_ver = old_versions[gem]
            if old_ver && old_ver != new_ver
              upgrades << { gem: gem, old: old_ver, new: new_ver }
            end
          end
          
          puts "## Dependency Upgrades Detected:"
          if upgrades.empty?
            puts "No version changes detected"
          else
            upgrades.each do |u|
              puts "- #{u[:gem]}: #{u[:old]} â†’ #{u[:new]}"
            end
          end
          
          # Save to file for later use
          File.open('upgrades.txt', 'w') do |f|
            upgrades.each do |u|
              f.puts "#{u[:gem]}|#{u[:old]}|#{u[:new]}"
            end
          end
          RUBY_EOF
            
            ruby detect_upgrades.rb | tee upgrade_detection.txt
            
            if [ -f upgrades.txt ] && [ -s upgrades.txt ]; then
              echo "has_upgrades=true" >> $GITHUB_OUTPUT
              echo "ðŸ“Š Upgrade Summary:"
              cat upgrade_detection.txt
            else
              echo "has_upgrades=false" >> $GITHUB_OUTPUT
              echo "No upgrades detected"
            fi
          else
            echo "âš ï¸ Could not fetch base branch Gemfile.lock, skipping upgrade detection"
            echo "has_upgrades=false" >> $GITHUB_OUTPUT
          fi

      # ============================================
      # Fetch Changelogs/Release Notes
      # ============================================
      - name: Fetch upgrade guides and changelogs
        if: steps.detect_upgrades.outputs.has_upgrades == 'true'
        id: fetch_changelogs
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ“š Fetching changelogs for upgraded gems..."
          
          cat > fetch_changelogs.rb << 'RUBY_EOF'
          require 'net/http'
          require 'uri'
          require 'json'
          
          def fetch_github_release_notes(gem_name, old_version, new_version)
            # Try common GitHub repo patterns
            potential_repos = [
              "#{gem_name}/#{gem_name}",
              "rails/#{gem_name}",
              "#{gem_name.gsub('-', '_')}/#{gem_name.gsub('-', '_')}"
            ]
            
            potential_repos.each do |repo|
              begin
                uri = URI("https://api.github.com/repos/#{repo}/releases")
                req = Net::HTTP::Get.new(uri)
                req['Accept'] = 'application/vnd.github.v3+json'
                req['Authorization'] = "token #{ENV['GH_TOKEN']}" if ENV['GH_TOKEN']
                
                res = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true, read_timeout: 10) { |http|
                  http.request(req)
                }
                
                if res.is_a?(Net::HTTPSuccess)
                  releases = JSON.parse(res.body)
                  relevant_releases = releases.select { |r| 
                    tag = r['tag_name'].gsub(/^v/, '')
                    tag >= old_version && tag <= new_version
                  }
                  
                  if relevant_releases.any?
                    return {
                      source: "GitHub releases (#{repo})",
                      notes: relevant_releases.map { |r| 
                        "### #{r['name'] || r['tag_name']}\n#{r['body']}" 
                      }.join("\n\n")
                    }
                  end
                end
              rescue => e
                # Try next repo
              end
            end
            nil
          end
          
          def fetch_rubygems_changelog(gem_name)
            begin
              uri = URI("https://rubygems.org/api/v1/gems/#{gem_name}.json")
              res = Net::HTTP.get_response(uri)
              if res.is_a?(Net::HTTPSuccess)
                data = JSON.parse(res.body)
                changelog_uri = data['changelog_uri'] || data['source_code_uri']
                return { source: "RubyGems", url: changelog_uri } if changelog_uri
              end
            rescue => e
              # Ignore
            end
            nil
          end
          
          upgrades_file = 'upgrades.txt'
          unless File.exist?(upgrades_file)
            puts "No upgrades file found"
            exit 0
          end
          
          all_notes = []
          File.readlines(upgrades_file).each do |line|
            gem_name, old_ver, new_ver = line.strip.split('|')
            next unless gem_name
            
            puts "Fetching notes for #{gem_name} (#{old_ver} â†’ #{new_ver})..."
            
            notes = fetch_github_release_notes(gem_name, old_ver, new_ver)
            unless notes
              notes = fetch_rubygems_changelog(gem_name)
            end
            
            if notes
              all_notes << "## #{gem_name} (#{old_ver} â†’ #{new_ver})\n"
              if notes[:notes]
                all_notes << notes[:notes]
              elsif notes[:url]
                all_notes << "Changelog: #{notes[:url]}"
              end
              all_notes << "\n---\n"
            else
              all_notes << "## #{gem_name} (#{old_ver} â†’ #{new_ver})\n"
              all_notes << "No changelog found. Check: https://rubygems.org/gems/#{gem_name}\n---\n"
            end
          end
          
          File.write('changelogs.txt', all_notes.join("\n")) if all_notes.any?
          RUBY_EOF
          
          ruby fetch_changelogs.rb 2>&1 | tee changelog_fetch.log
          
          if [ -f changelogs.txt ]; then
            echo "âœ… Fetched changelogs"
            echo "changelogs_available=true" >> $GITHUB_OUTPUT
            
            echo "## ðŸ“š Upgrade Guides & Changelogs" >> $GITHUB_STEP_SUMMARY
            echo '```text' >> $GITHUB_STEP_SUMMARY
            head -100 changelogs.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ No changelogs fetched"
            echo "changelogs_available=false" >> $GITHUB_OUTPUT
          fi

      # ============================================
      # Initial test run
      # ============================================
      - name: Run initial tests
        id: initial_tests
        continue-on-error: true
        run: |
          set +e
          bin/rails test:prepare > test_output.txt 2>&1
          bin/rails test >> test_output.txt 2>&1
          TEST_EXIT=$?
          echo "test_exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT
          
          echo "## Initial Test Output" >> $GITHUB_STEP_SUMMARY
          echo '```text' >> $GITHUB_STEP_SUMMARY
          cat test_output.txt | tail -n 50 >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "Exit code: $TEST_EXIT" >> $GITHUB_STEP_SUMMARY

      # ============================================
      # Auto-fix loop - Iteration 1
      # ============================================
      - name: Auto-fix iteration 1
        if: steps.initial_tests.outputs.test_exit_code != '0'
        id: fix_iteration_1
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Iteration 1: Analyzing failures and generating fixes..."
          
          # Build enhanced AI prompt with upgrade context
          cat > prompt_1.txt << 'PROMPT_EOF'
          You are an expert Ruby on Rails developer. Tests failed after dependency upgrades. Analyze and fix.

          PROMPT_EOF
          
          # Add upgrade context if available
          if [ -f upgrade_detection.txt ]; then
            cat >> prompt_1.txt << 'PROMPT_EOF'
          ## Dependency Upgrades:
          PROMPT_EOF
            cat upgrade_detection.txt >> prompt_1.txt
            echo "" >> prompt_1.txt
          fi
          
          # Add changelogs if available
          if [ -f changelogs.txt ]; then
            cat >> prompt_1.txt << 'PROMPT_EOF'
          ## Upgrade Guides & Breaking Changes:
          The following gems were upgraded. Review their changelogs for breaking changes:

          PROMPT_EOF
            head -200 changelogs.txt >> prompt_1.txt
            echo "" >> prompt_1.txt
          fi
          
          cat >> prompt_1.txt << 'PROMPT_EOF'

          ## Test Output (showing failures):
          PROMPT_EOF
          
          tail -n 150 test_output.txt >> prompt_1.txt
          
          cat >> prompt_1.txt << 'PROMPT_EOF'

          ## Gemfile:
          PROMPT_EOF
          cat Gemfile >> prompt_1.txt
          
          cat >> prompt_1.txt << 'PROMPT_EOF'

          ## Source Files (relevant to failures):
          PROMPT_EOF
          
          # Extract file paths from error messages and include them
          grep -oP '(?<=in `)(.+?)(?=:)' test_output.txt 2>/dev/null | grep "^app/" | sort -u | head -5 | while read file; do
            if [ -f "$file" ]; then
              echo "### File: $file" >> prompt_1.txt
              echo '```ruby' >> prompt_1.txt
              cat "$file" >> prompt_1.txt
              echo '```' >> prompt_1.txt
              echo "" >> prompt_1.txt
            fi
          done
          
          cat >> prompt_1.txt << 'PROMPT_EOF'

          ## Your Task:
          1. **Identify the root cause**: Focus on breaking changes from upgraded dependencies
          2. **Provide specific fixes**: Include file paths, exact code changes
          3. **Handle common upgrade issues**: 
             - Method signature changes (argument count, keyword args)
             - Renamed/moved methods or classes
             - Configuration changes
             - Import/require statement updates
          4. **Format your response as**:

          ### ANALYSIS:
          [Brief explanation of what broke and why - mention specific gem if relevant]

          ### FIX: path/to/file.rb
          ```ruby
          # Exact code to add/change
          # Include enough context to locate the code
          ```

          ### FIX: path/to/another_file.rb
          ```ruby
          # More fixes if needed
          ```

          ### COMMIT_MESSAGE: 
          fix: [brief description mentioning the dependency upgrade]

          **Important**: 
          - Be specific and actionable
          - If a gem changed its API, show the OLD way and NEW way
          - For method signature changes, show the updated call with correct arguments
          - Include all necessary changes, even if across multiple files
          PROMPT_EOF
          
          echo "## AI Prompt (iteration 1)" >> $GITHUB_STEP_SUMMARY
          echo '```text' >> $GITHUB_STEP_SUMMARY
          head -50 prompt_1.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          # Call GitHub Models API with proper authentication
          if python3 .github/scripts/call_github_models.py < prompt_1.txt > fixes_iteration_1.txt 2>&1; then
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          else
            echo "Failed to get AI suggestions" >> fixes_iteration_1.txt
            echo "fixes_generated=false" >> $GITHUB_OUTPUT
          fi
          
          echo "## AI Response (iteration 1)" >> $GITHUB_STEP_SUMMARY
          echo '```text' >> $GITHUB_STEP_SUMMARY
          cat fixes_iteration_1.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Apply fixes iteration 1
        if: steps.fix_iteration_1.outputs.fixes_generated == 'true'
        id: apply_fixes_1
        run: |
          python3 .github/scripts/apply_fixes.py fixes_iteration_1.txt

          if [ -f fixes_iteration_1.txt ]; then
            # Re-run bundle install if Gemfile was modified
            if git diff --name-only | grep -q 'Gemfile'; then
              echo "Gemfile was modified, re-running bundle install..."
              bundle install --jobs 4
            fi
          fi

          if git status --porcelain | grep -q .; then
            echo "fixes_applied=true" >> $GITHUB_OUTPUT
          else
            echo "fixes_applied=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push iteration 1
        if: steps.apply_fixes_1.outputs.fixes_applied == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          COMMIT_MSG=$(grep "COMMIT_MESSAGE:" fixes_iteration_1.txt 2>/dev/null | head -1 | sed 's/COMMIT_MESSAGE: *//' | tr -d '\r')
          if [ -z "$COMMIT_MSG" ]; then COMMIT_MSG="fix: auto-fix iteration 1"; fi
          git add -A
          git commit -m "$COMMIT_MSG"
          git push origin HEAD

      - name: Test after iteration 1
        if: steps.apply_fixes_1.outputs.fixes_applied == 'true'
        id: test_after_fix_1
        continue-on-error: true
        run: |
          set +e
          bin/rails test:prepare > test_output_1.txt 2>&1
          bin/rails test >> test_output_1.txt 2>&1
          TEST_EXIT=$?
          cat test_output_1.txt
          echo "test_exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT

      # ============================================
      # Auto-fix loop - Iteration 2
      # ============================================
      - name: Auto-fix iteration 2
        if: steps.test_after_fix_1.outputs.test_exit_code != '0'
        id: fix_iteration_2
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Iteration 2: Analyzing remaining failures..."
          
          # Build prompt with context
          cat > prompt_2.txt << 'PROMPT_EOF'
          You are a Ruby/Rails expert. Previous fixes didn't resolve all test failures. Analyze remaining issues.

          PROMPT_EOF
          
          if [ -f upgrade_detection.txt ]; then
            echo "## Dependency Upgrades:" >> prompt_2.txt
            cat upgrade_detection.txt >> prompt_2.txt
            echo "" >> prompt_2.txt
          fi
          
          if [ -f changelogs.txt ]; then
            echo "## Breaking Changes (from changelogs):" >> prompt_2.txt
            head -150 changelogs.txt >> prompt_2.txt
            echo "" >> prompt_2.txt
          fi
          
          echo "## Test Output (iteration 2):" >> prompt_2.txt
          tail -n 150 test_output_1.txt >> prompt_2.txt
          
          echo "" >> prompt_2.txt
          echo "## Previous Fix Attempt:" >> prompt_2.txt
          cat fixes_iteration_1.txt | head -50 >> prompt_2.txt
          
          echo "" >> prompt_2.txt
          echo "## Task: Fix remaining issues using ### FIX: path/to/file format" >> prompt_2.txt
          
          if python3 .github/scripts/call_github_models.py < prompt_2.txt > fixes_iteration_2.txt 2>&1; then
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          else
            echo "Failed - models unavailable" > fixes_iteration_2.txt
            echo "fixes_generated=false" >> $GITHUB_OUTPUT
          fi
          cat fixes_iteration_2.txt

      - name: Apply fixes iteration 2
        if: steps.fix_iteration_2.outputs.fixes_generated == 'true'
        run: |
          python3 .github/scripts/apply_fixes.py fixes_iteration_2.txt

          if git diff --name-only | grep -q 'Gemfile'; then
            bundle install --jobs 4
          fi

          if git status --porcelain | grep -q .; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            COMMIT_MSG=$(grep "COMMIT_MESSAGE:" fixes_iteration_2.txt 2>/dev/null | head -1 | sed 's/COMMIT_MESSAGE: *//' | tr -d '\r')
            if [ -z "$COMMIT_MSG" ]; then COMMIT_MSG="fix: iteration 2"; fi
            git add -A
            git commit -m "$COMMIT_MSG"
            git push origin HEAD
          fi

      - name: Test after iteration 2
        if: steps.fix_iteration_2.outputs.fixes_generated == 'true'
        id: test_after_fix_2
        continue-on-error: true
        run: |
          set +e
          bin/rails test:prepare > test_output_2.txt 2>&1
          bin/rails test >> test_output_2.txt 2>&1
          TEST_EXIT=$?
          cat test_output_2.txt
          echo "test_exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT

      # ============================================
      # Auto-fix loop - Iteration 3 (Final)
      # ============================================
      - name: Auto-fix iteration 3 (final)
        if: steps.test_after_fix_2.outputs.test_exit_code != '0'
        id: fix_iteration_3
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Iteration 3: Final fix attempt..."
          
          # Build final prompt with all context
          cat > prompt_3.txt << 'PROMPT_EOF'
          You are a Ruby/Rails expert. This is the FINAL attempt to fix test failures after dependency upgrades.

          PROMPT_EOF
          
          if [ -f upgrade_detection.txt ]; then
            echo "## Dependency Upgrades:" >> prompt_3.txt
            cat upgrade_detection.txt >> prompt_3.txt
            echo "" >> prompt_3.txt
          fi
          
          if [ -f changelogs.txt ]; then
            echo "## Breaking Changes:" >> prompt_3.txt
            head -150 changelogs.txt >> prompt_3.txt
            echo "" >> prompt_3.txt
          fi
          
          echo "## Test Output (iteration 3):" >> prompt_3.txt
          tail -n 150 test_output_2.txt >> prompt_3.txt
          
          echo "" >> prompt_3.txt
          echo "## Previous Attempts:" >> prompt_3.txt
          echo "### Fix 1:" >> prompt_3.txt
          cat fixes_iteration_1.txt | head -30 >> prompt_3.txt
          echo "### Fix 2:" >> prompt_3.txt
          cat fixes_iteration_2.txt | head -30 >> prompt_3.txt
          
          echo "" >> prompt_3.txt
          echo "## Task: Provide comprehensive fix using ### FIX: path/to/file format" >> prompt_3.txt
          
          if python3 .github/scripts/call_github_models.py < prompt_3.txt > fixes_iteration_3.txt 2>&1; then
            echo "fixes_generated=true" >> $GITHUB_OUTPUT
          else
            echo "Failed - models unavailable" > fixes_iteration_3.txt
            echo "fixes_generated=false" >> $GITHUB_OUTPUT
          fi
          cat fixes_iteration_3.txt

      - name: Apply fixes iteration 3
        if: steps.fix_iteration_3.outputs.fixes_generated == 'true'
        run: |
          python3 .github/scripts/apply_fixes.py fixes_iteration_3.txt

          if git diff --name-only | grep -q 'Gemfile'; then
            bundle install --jobs 4
          fi

          if git status --porcelain | grep -q .; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            COMMIT_MSG=$(grep "COMMIT_MESSAGE:" fixes_iteration_3.txt 2>/dev/null | head -1 | sed 's/COMMIT_MESSAGE: *//' | tr -d '\r')
            if [ -z "$COMMIT_MSG" ]; then COMMIT_MSG="fix: iteration 3 final"; fi
            git add -A
            git commit -m "$COMMIT_MSG"
            git push origin HEAD
          fi

      - name: Final test
        if: steps.fix_iteration_3.outputs.fixes_generated == 'true'
        id: final_test
        continue-on-error: true
        run: |
          set +e
          bin/rails test:prepare > final_test_output.txt 2>&1
          bin/rails test >> final_test_output.txt 2>&1
          TEST_EXIT=$?
          cat final_test_output.txt
          echo "test_exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT

      # ============================================
      # Summary
      # ============================================
      - name: Summary
        if: always()
        run: |
          echo "## Dependabot Auto-Fix Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          INITIAL_EXIT="${{ steps.initial_tests.outputs.test_exit_code }}"
          FIX1_EXIT="${{ steps.test_after_fix_1.outputs.test_exit_code }}"
          FIX2_EXIT="${{ steps.test_after_fix_2.outputs.test_exit_code }}"
          FINAL_EXIT="${{ steps.final_test.outputs.test_exit_code }}"

          if [ "$INITIAL_EXIT" == "0" ]; then
            echo "âœ… Tests passed on first run - no fixes needed" >> $GITHUB_STEP_SUMMARY
          elif [ -n "$INITIAL_EXIT" ]; then
            echo "Tests failed - applied fixes..." >> $GITHUB_STEP_SUMMARY

            if [ "$FIX1_EXIT" == "0" ]; then
              echo "âœ… Tests passed after iteration 1" >> $GITHUB_STEP_SUMMARY
            elif [ "$FIX2_EXIT" == "0" ]; then
              echo "âœ… Tests passed after iteration 2" >> $GITHUB_STEP_SUMMARY
            elif [ "$FINAL_EXIT" == "0" ]; then
              echo "âœ… Tests passed after iteration 3" >> $GITHUB_STEP_SUMMARY
            elif [ -n "$FINAL_EXIT" ]; then
              echo "âŒ Tests still failing after 3 iterations - manual review required" >> $GITHUB_STEP_SUMMARY
            else
              echo "âš ï¸ Auto-fix iterations incomplete - check logs" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âš ï¸ Initial tests did not run - check workflow conditions" >> $GITHUB_STEP_SUMMARY
          fi
