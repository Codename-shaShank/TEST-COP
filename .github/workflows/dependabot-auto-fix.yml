name: Auto-fix Dependabot Gem Failures

on:
  pull_request:
    paths:
      - 'Gemfile'
      - 'Gemfile.lock'
    types: [opened, reopened, synchronize]

jobs:
  auto-fix-gems:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      # ============================================
      # STAGE 1: Generate gem change summary
      # ============================================
      - name: Generate gem change summary
        id: gem_summary
        run: |
          if [ -f .github/scripts/gem_diff.rb ]; then
            ruby .github/scripts/gem_diff.rb > gem_summary.txt 2>&1
            echo "GEM_SUMMARY<<EOF" >> $GITHUB_ENV
            cat gem_summary.txt >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è  gem_diff.rb not found, skipping summary"
          fi

      # ============================================
      # STAGE 2: Initial test run
      # ============================================
      - name: Run tests (initial)
        id: initial_tests
        continue-on-error: true
        run: |
          bundle exec rspec --format progress --format RspecJunitFormatter --out rspec.xml 2>&1 | tee test_output.txt
          echo "TEST_COUNT=$(grep -c 'passed\|failed' test_output.txt || echo '0')" >> $GITHUB_ENV

      # ============================================
      # STAGE 3-6: Looping fix attempts (max 3 iterations)
      # ============================================
      - name: Attempt fix iteration 1
        if: steps.initial_tests.outcome == 'failure'
        id: fix_attempt_1
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ITERATION: 1
        run: |
          echo "üîÑ Iteration 1: Getting Copilot fix suggestions..."
          
          FAILURES=$(cat test_output.txt | head -200)
          GEM_CHANGES=$(git diff origin/main Gemfile.lock | head -150)
          
          PROMPT=$(cat <<'PROMPT_END'
          You are a Ruby on Rails expert. A Dependabot gem upgrade broke the application.
          
          **Gem Changes:**
          PROMPT_END
          echo "$GEM_CHANGES"
          cat <<'PROMPT_END'
          
          **Test Failures:**
          PROMPT_END
          echo "$FAILURES"
          cat <<'PROMPT_END'
          
          **Your task:**
          1. Identify which files need fixes based on the gem changes and test failures
          2. Provide ONLY code fixes for app/, config/, db/ directories
          3. Format fixes exactly as:
          
          FILE: path/to/file.rb
          ```ruby
          fixed code here
          ```
          
          4. Add brief comments explaining the version-specific change
          5. DO NOT modify Gemfile, Gemfile.lock, or spec files
          6. Return ONLY the code fixes, no explanations
          PROMPT_END
          )
          
          gh models run claude-3-5-sonnet-20241022 --input "$PROMPT" > copilot_fixes_1.txt 2>&1
          cat copilot_fixes_1.txt

      - name: Apply fixes iteration 1
        if: steps.initial_tests.outcome == 'failure' && steps.fix_attempt_1.outcome == 'success'
        id: apply_fixes_1
        run: |
          echo "üìù Applying Copilot fixes (iteration 1)..."
          
          ruby << 'EOF'
          require 'pathname'
          
          fixes_file = 'copilot_fixes_1.txt'
          return unless File.exist?(fixes_file)
          
          fixes_text = File.read(fixes_file)
          fix_count = 0
          
          # Parse FILE: and code blocks
          fixes_text.scan(/FILE:\s*(.+?)\s+```ruby\s*(.+?)\s*```/m) do |file, code|
            file = file.strip
            code = code.strip
            
            # Safety checks
            if file.include?('Gemfile') || file.include?('spec') || file.include?('test')
              puts "‚è≠Ô∏è  Skipping protected file: #{file}"
              next
            end
            
            unless File.exist?(file)
              puts "‚ö†Ô∏è  File not found: #{file}, creating it"
            end
            
            # Write the fix
            File.write(file, code)
            puts "‚úÖ Fixed: #{file}"
            fix_count += 1
          end
          
          puts "üìä Applied #{fix_count} fixes"
          EOF

      - name: Re-run tests iteration 1
        if: steps.initial_tests.outcome == 'failure'
        id: retest_1
        continue-on-error: true
        run: |
          echo "üß™ Re-running tests after fixes (iteration 1)..."
          bundle exec rspec --format progress 2>&1 | tee test_output_1.txt

      # ============================================
      # ITERATION 2 (if still failing)
      # ============================================
      - name: Attempt fix iteration 2
        if: steps.retest_1.outcome == 'failure'
        id: fix_attempt_2
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Iteration 2: Getting refined Copilot fixes..."
          
          FAILURES=$(cat test_output_1.txt | head -200)
          PREVIOUS_FIX=$(cat copilot_fixes_1.txt | head -100)
          
          PROMPT=$(cat <<'PROMPT_END'
          The previous fix attempt didn't fully resolve the test failures.
          
          **Previous fix applied:**
          PROMPT_END
          echo "$PREVIOUS_FIX"
          cat <<'PROMPT_END'
          
          **Remaining failures:**
          PROMPT_END
          echo "$FAILURES"
          cat <<'PROMPT_END'
          
          Provide more refined fixes with better understanding of the gem version changes.
          Format as before: FILE: path CODE: ```ruby ... ```
          PROMPT_END
          )
          
          gh models run claude-3-5-sonnet-20241022 --input "$PROMPT" > copilot_fixes_2.txt 2>&1
          cat copilot_fixes_2.txt

      - name: Apply fixes iteration 2
        if: steps.retest_1.outcome == 'failure' && steps.fix_attempt_2.outcome == 'success'
        id: apply_fixes_2
        run: |
          echo "üìù Applying Copilot fixes (iteration 2)..."
          
          ruby << 'EOF'
          require 'pathname'
          
          fixes_file = 'copilot_fixes_2.txt'
          return unless File.exist?(fixes_file)
          
          fixes_text = File.read(fixes_file)
          fix_count = 0
          
          fixes_text.scan(/FILE:\s*(.+?)\s+```ruby\s*(.+?)\s*```/m) do |file, code|
            file = file.strip
            code = code.strip
            
            if file.include?('Gemfile') || file.include?('spec') || file.include?('test')
              puts "‚è≠Ô∏è  Skipping: #{file}"
              next
            end
            
            File.write(file, code)
            puts "‚úÖ Fixed: #{file}"
            fix_count += 1
          end
          
          puts "üìä Applied #{fix_count} fixes"
          EOF

      - name: Re-run tests iteration 2
        if: steps.retest_1.outcome == 'failure'
        id: retest_2
        continue-on-error: true
        run: |
          echo "üß™ Re-running tests after fixes (iteration 2)..."
          bundle exec rspec --format progress 2>&1 | tee test_output_2.txt

      # ============================================
      # ITERATION 3 (final attempt)
      # ============================================
      - name: Attempt fix iteration 3
        if: steps.retest_2.outcome == 'failure'
        id: fix_attempt_3
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Iteration 3 (final): Getting comprehensive Copilot fixes..."
          
          FAILURES=$(cat test_output_2.txt | head -250)
          
          PROMPT=$(cat <<'PROMPT_END'
          This is the final attempt. The tests are still failing after 2 previous fix iterations.
          
          **Current failures:**
          PROMPT_END
          echo "$FAILURES"
          cat <<'PROMPT_END'
          
          Review ALL test failures and provide comprehensive fixes that address the root cause.
          Check for:
          - API changes in upgraded gems
          - Configuration changes needed
          - Callback/hook changes
          - Method signature changes
          
          Format: FILE: path CODE: ```ruby ... ```
          PROMPT_END
          )
          
          gh models run claude-3-5-sonnet-20241022 --input "$PROMPT" > copilot_fixes_3.txt 2>&1
          cat copilot_fixes_3.txt

      - name: Apply fixes iteration 3
        if: steps.retest_2.outcome == 'failure' && steps.fix_attempt_3.outcome == 'success'
        id: apply_fixes_3
        run: |
          echo "üìù Applying Copilot fixes (iteration 3 - final)..."
          
          ruby << 'EOF'
          require 'pathname'
          
          fixes_file = 'copilot_fixes_3.txt'
          return unless File.exist?(fixes_file)
          
          fixes_text = File.read(fixes_file)
          fix_count = 0
          
          fixes_text.scan(/FILE:\s*(.+?)\s+```ruby\s*(.+?)\s*```/m) do |file, code|
            file = file.strip
            code = code.strip
            
            if file.include?('Gemfile') || file.include?('spec') || file.include?('test')
              puts "‚è≠Ô∏è  Skipping: #{file}"
              next
            end
            
            File.write(file, code)
            puts "‚úÖ Fixed: #{file}"
            fix_count += 1
          end
          
          puts "üìä Applied #{fix_count} fixes"
          EOF

      - name: Final test run
        if: steps.retest_2.outcome == 'failure'
        id: final_tests
        continue-on-error: true
        run: |
          echo "üß™ Final test run (after iteration 3)..."
          bundle exec rspec --format progress 2>&1 | tee test_output_final.txt

      # ============================================
      # STAGE 6: Commit and push all fixes
      # ============================================
      - name: Commit and push all fixes
        if: steps.initial_tests.outcome == 'failure'
        run: |
          git config user.email "github-actions[bot]@github.com"
          git config user.name "github-actions[bot]"
          
          git add -A
          
          COMMIT_MESSAGE=$(cat <<'MSG'
          fix: Update code for gem upgrade compatibility
          
          Applied Copilot-generated fixes for Dependabot gem upgrades:
          - Iteration 1: Initial compatibility fixes
          MSG
          )
          
          if [ -f copilot_fixes_2.txt ] && grep -q "FILE:" copilot_fixes_2.txt; then
            COMMIT_MESSAGE="${COMMIT_MESSAGE}
          - Iteration 2: Refined fixes"
          fi
          
          if [ -f copilot_fixes_3.txt ] && grep -q "FILE:" copilot_fixes_3.txt; then
            COMMIT_MESSAGE="${COMMIT_MESSAGE}
          - Iteration 3: Comprehensive fixes"
          fi
          
          COMMIT_MESSAGE="${COMMIT_MESSAGE}
          
          See .github/scripts/gem_diff.rb output for detailed gem changes.
          This was automatically generated by Copilot via GitHub Models API."
          
          git commit -m "$COMMIT_MESSAGE" || echo "‚ùå No changes to commit"
          git push origin HEAD:${{ github.head_ref }} || echo "Failed to push"

      # ============================================
      # STAGE 7: Summary
      # ============================================
      - name: Test result summary
        if: always()
        run: |
          echo "## üìä Dependabot Gem Upgrade - Auto-Fix Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Initial Test Status" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.initial_tests.outcome }}" == "success" ]; then
            echo "‚úÖ **Tests PASSED on first run - No fixes needed**" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Tests FAILED - Copilot fixes applied**" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f copilot_fixes_1.txt ]; then
            echo "### Iteration 1 Fixes" >> $GITHUB_STEP_SUMMARY
            grep "^FILE:" copilot_fixes_1.txt | sed 's/FILE: /- /' >> $GITHUB_STEP_SUMMARY || echo "No fixes" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.retest_1.outcome }}" == "success" ]; then
            echo "‚úÖ **Tests PASSED after iteration 1**" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.retest_1.outcome }}" == "failure" ] && [ -n "${{ steps.fix_attempt_2.outcome }}" ]; then
            echo "### Iteration 2 Fixes" >> $GITHUB_STEP_SUMMARY
            grep "^FILE:" copilot_fixes_2.txt | sed 's/FILE: /- /' >> $GITHUB_STEP_SUMMARY || echo "No fixes" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.retest_2.outcome }}" == "success" ]; then
            echo "‚úÖ **Tests PASSED after iteration 2**" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.retest_2.outcome }}" == "failure" ] && [ -n "${{ steps.fix_attempt_3.outcome }}" ]; then
            echo "### Iteration 3 Fixes (Final)" >> $GITHUB_STEP_SUMMARY
            grep "^FILE:" copilot_fixes_3.txt | sed 's/FILE: /- /' >> $GITHUB_STEP_SUMMARY || echo "No fixes" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.final_tests.outcome }}" == "success" ]; then
            echo "‚úÖ **Tests PASSED after final iteration**" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.final_tests.outcome }}" == "failure" ]; then
            echo "‚ö†Ô∏è  **Tests still failing after all iterations**" >> $GITHUB_STEP_SUMMARY
            echo "Manual review recommended." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Gem Changes Summary" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          head -20 gem_summary.txt >> $GITHUB_STEP_SUMMARY || echo "No summary available" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "ü§ñ *Powered by GitHub Copilot + GitHub Models API*" >> $GITHUB_STEP_SUMMARY
